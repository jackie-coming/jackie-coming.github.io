# 前序
![image.png](https://cdn.nlark.com/yuque/0/2024/png/758294/1709539779061-12f9250d-d74d-42a3-920a-4c5633d7014f.png#averageHue=%237a795c&clientId=u3f264856-2afb-4&from=paste&height=518&id=uc7451a3b&originHeight=1035&originWidth=973&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1066672&status=done&style=none&taskId=u5e63ac2e-2b50-4e8d-bc18-a6142866fa4&title=&width=486.5)

![image.png](https://cdn.nlark.com/yuque/0/2024/png/758294/1709538551874-c5d17951-45b0-4c86-8cb2-1647c87ac442.png#averageHue=%23171048&clientId=u7aedc3fd-9b9c-4&from=paste&height=470&id=u8e16c209&originHeight=939&originWidth=993&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1530514&status=done&style=none&taskId=u91c74545-d540-4eeb-a097-bf944295709&title=&width=496.5)
**中文书的出版时间**

- 《小工到专家》 2005年出版
- 《通向务实的最高境界》第二版 2020年出版

**英文书的出版时间**

   - 《The Pragmatic Programmer： From Journeyman to Master》 1999年
   - 《The Pragmatic Programmer: Your Journey To Mastery, 20th Anniversary Edition (2nd Edition)》 2019 年

**作者**

- Andy Hunt是一位木匠和音乐家
- Dave Thomas喜欢驾驶单引擎飞机

**涵盖的主题**：个人责任、职业发展、代码保持灵活、易于改编和复用的各种架构技术
**适用对象**：初学者、有经验的程序员
**给出的建议**：
1、尽可能阅读原著，看一手信息，减少翻译过程的gap
2、每一个原则都需要细品，多读几遍同时必须要实践
3、频繁的高强度的外部刺激（遇到的项目、团队）和自主的有意识的反复提醒有利于加速原则和知识的内化
**陈述的方式**：书中的观点+背景+解决方案+结合材料展开（网上的例子、观点、附录中提到的论文和资源）
# 个人成长
## 我的源码让猫给吃了
![image.png](https://cdn.nlark.com/yuque/0/2024/png/758294/1709541400172-423d6166-3708-4e47-b7b9-183ac2f27d91.png#averageHue=%23b29e8f&clientId=ue647fcaa-c1e8-4&from=paste&height=333&id=uaeea7660&originHeight=666&originWidth=1000&originalType=binary&ratio=2&rotation=0&showTitle=false&size=769299&status=done&style=none&taskId=u525d7a3e-2c5b-4649-9283-2383bfdccc3&title=&width=500)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/758294/1708228217762-077946e9-049d-476f-b3b6-4d1ea43bd163.png#averageHue=%23c7c7c7&clientId=u4140d099-0619-4&from=paste&height=610&id=wZsVj&originHeight=610&originWidth=1672&originalType=binary&ratio=1&rotation=0&showTitle=false&size=164038&status=done&style=none&taskId=u8cf04b65-7004-4c6d-bc86-562e46782cb&title=&width=1672)
### 负责
**原则：**
![image.png](https://cdn.nlark.com/yuque/0/2024/png/758294/1709542049760-cbf4142a-5eb0-4a1b-a4cd-bd36668bb454.png#averageHue=%23a4a4a4&clientId=ue647fcaa-c1e8-4&from=paste&height=118&id=u446c5c75&originHeight=142&originWidth=719&originalType=binary&ratio=2&rotation=0&showTitle=false&size=29856&status=done&style=none&taskId=ud0868f1f-29c6-4457-bd52-32911f6aae1&title=&width=595.5)
**背景：**你承诺确保某件事情正确完成，但是不一定可以直接控制事情的每一个方面，除了尽可能完成之外，还必须得先分析风险是否超出了控制。
**解决方案**：
分析风险是否可控

- 如果是风险无法控制的事情，有权不为项目的结果负责
- 如果同意为项目的结果负责，出现问题时，不是找借口，而是给出各种可行的解决方案。
   - 如果需要额外的资源，不要害怕提出要求，也不要害怕承认需要帮助

如果你犯了错误，不能履行那些责任，你必须弥补它，并找到解决办法。不要找借口。你不能去上班然后告诉大家有只猫吃了你的源代码。
## 你的知识资产
知识资产是有时效的。
### 工程师如何学习？
#### 书中观点

- 知识和经验是最重要的专业资产，但是也是一种时效资产。
- 构建知识组合
   - 定期投资
      - 每年学习一门新语言
      - 每月读一本技术书
      - 读非技术书
      - 上课
      - 加入社群
      - 尝试不同的环境（开发环境）
      - 与时俱进
   - 多样化：知道的越多，价值越大。熟悉的技能越多，越能适应变化。
   - 风险管理：不要把所有的技术鸡蛋都放在一个篮子里。
   - 低买高卖：在一项新兴技术变得流行之前就开始学习。
   - 重新评估调整：不断尝试，温故而知新
- 学习的机会（与人交流、碎片化阅读）
- 批评性思维：知识的精确性容易受到商业主义的影响
   - 多问“为什么“
   - （世俗的怀疑）谁从中受益
   - 有什么背景：每件事都发生在它自己的背景下
   - 什么时候在哪里可以工作起来：当它结束后还会发生什么（二阶思考）
   - 为什么这是个问题
#### 引用观点
go业界大佬曹大的博客关于这个话题给出了一些学习方法和经验，个人感觉非常有用

- 阅读书籍
   - 网络博客有什么缺点？
      - 网络博客内容缺乏体系，不系统，很多博主为了掩饰自己的未知，不懂的关键点就一笔带过，最终获取的只是二手资料
   - 能够读懂英文技术书籍是工程师的硬实力，大部分优秀的技术书籍以英文为主
      - 英语阅读能力怎么训练？逼迫自己去翻译一些英文文档
         - 翻译The Go Programming Language
         - 翻译 es权威指南		
- 实时信息源
   - 技术书籍存在一个明显的缺点，时效问题
   - github trending
      - github trending代表一种风向
   - follow优秀的工程师
      - 希望自己能在技术上做到一直精进，同时随着年龄和工龄的增长又会时不时陷入迷茫，这时候去看看同龄的优秀工程师，年纪更大的优秀工程师在这个时间段在写什么代码，在写什么博客，可能对于解决自己特定时期的迷茫有益。或许就发现了一个新的领域值得自己去奉献青春。
   - reddit相关社区
      - 国内的社区生态被人为地割裂了，建议关注国外的社区
   - 阅读论文
      - 除了工程之外，前言的理论知识需要通过论文去了解
   - 技术会议和公开课
      - 除了阅读文字之外，阅览视频和与人面对面交流有时候不可缺少
      - youtube
      - b站
   - 多做开源
      - 业余时间，用最严格的标准来要求自己编写自己的开源项目
   - 多做总结
      - 建立自己的blog
- 锻炼演技
   - 软技能的训练，提前做好准备

# 代码架构
## 软件的熵
当软件中的无序增长时，程序员们称之为“软件腐烂”
![image.png](https://cdn.nlark.com/yuque/0/2024/png/758294/1709542179626-15f24164-6760-4426-ba73-9a4905241fc4.png#averageHue=%23d4d6d4&clientId=ue647fcaa-c1e8-4&from=paste&height=334&id=uf67a6944&originHeight=667&originWidth=1000&originalType=binary&ratio=2&rotation=0&showTitle=false&size=917355&status=done&style=none&taskId=u9881c493-e1b6-4fff-84b3-472aab9f14b&title=&width=500)
**原则：**
![image.png](https://cdn.nlark.com/yuque/0/2024/png/758294/1709542922262-fe31bcb9-0d44-461c-8d36-d001feb0447a.png#averageHue=%23b0b0b0&clientId=ue647fcaa-c1e8-4&from=paste&height=136&id=u62d086ca&originHeight=161&originWidth=732&originalType=binary&ratio=2&rotation=0&showTitle=false&size=23955&status=done&style=none&taskId=u2f2baf7c-6414-4a74-a6fe-fbb8c7eba1b&title=&width=620)
> 破窗效应：一扇破损的窗户，只要一段时间不修理，建筑中的居民就会潜移默化地产生一种被遗弃的感觉——当权者不关心这幢建筑的感觉。然后其他的窗户也开始损坏，居民开始乱丢废物，墙上开始出现涂鸦，建筑开始出现严重的结构性损坏。心理学家的研究表明，绝望是会传染的，就像狭窄空间中的流感病毒。无视一个明显损坏的东西，会强化这样一种观念：看来没有什么是能修好的，也没人在乎，一切都命中决定了。所有的负面情绪会在团队成员间蔓延，变成恶性循环。

**背景：**破窗户代指：低劣的设计、错误的决策、糟糕的代码
**解决方案：**

1. 有时间：发现一个修一个
2. 没有时间：用木板把破窗户钉起来，采取行动防止进一步的损坏，并说明情势处在你的控制之下
   1. 出问题的代码加入注释
      1. 显示“未实现”消息，用虚设的数据加以替代
   2. 显示“未实现”消息

这很像我们的代码：当我们看到一些肮脏的代码（我们可以看到它是一个破碎的窗口），我们可能会开始认为，让代码是肮脏的。以后再去也没关系，但大多数时候我们都不去。
不要让“破碎的窗户”不修理。当你发现这种代码时，尽快修复它。当你继续认为没有人有时间去修复那些坏掉的代码时，你还不如去给自己买一个垃圾箱来保存你的代码。
## 重复的危害
维护不是时有时无的活动，而是整个开发过程中的例行事务。在我们开发的规范、过程和程序中很容易重复表示知识。 如果有多个地方表达同一个事务，需要更改其中一处的时候，必须记得改变其他各处。
优秀的设计比糟糕的设计更容易变更。

**原则1：**
![image.png](https://cdn.nlark.com/yuque/0/2024/png/758294/1709543746537-99c254e4-ff96-452f-b8d1-6205caf40a3c.png#averageHue=%23b0b0b0&clientId=ue647fcaa-c1e8-4&from=paste&height=122&id=u0618daca&originHeight=162&originWidth=742&originalType=binary&ratio=2&rotation=0&showTitle=false&size=27116&status=done&style=none&taskId=u34bdf92d-b084-4cc6-bae2-524ff7f18fc&title=&width=557)

- 强加的重复（imposed）：开发者觉得他们无可选择--环境似乎要求重复
   - 把注释保留给其他的高级说明
      - 如果把注释给低级的代码，我们就是在重复知识，每一次改变都意味着既要改变代码，又要改变注释
      - 不可信的注释比完全没有注释更糟糕
- 无意的重复(inadvertent)：开发者没有意识到他们在重复信息
   - 来自于设计中的错误![image.png](https://cdn.nlark.com/yuque/0/2024/png/758294/1708243154402-2cad43c4-72b2-4a94-ac2b-a2e4caf07a39.png#averageHue=%23d9d9d9&clientId=u7c009fbc-3bc0-4&from=paste&height=1022&id=UdSpd&originHeight=1022&originWidth=2140&originalType=binary&ratio=1&rotation=0&showTitle=false&size=386217&status=done&style=none&taskId=ua61faee5-6d38-4158-8412-0f862fa595e&title=&width=2140)
   - 可以因为性能原因而选择违反DRY原则，但是需要将影响局部化，对DRY原则的违反没有暴露给外界。
      - 经常发生在需要缓存数据的时候，只有类中的方法需要关注DRY,“保持行为良好”![image.png](https://cdn.nlark.com/yuque/0/2024/png/758294/1708243266447-a675bf4b-f2d6-48b7-9cbc-d9a766541127.png#averageHue=%23dadada&clientId=u7c009fbc-3bc0-4&from=paste&height=1066&id=CJ5SL&originHeight=1066&originWidth=1646&originalType=binary&ratio=1&rotation=0&showTitle=false&size=259060&status=done&style=none&taskId=u744bfdb4-be35-4cb2-b0aa-b219f64885e&title=&width=1646)
- 无奈性的重复(impatient)：开发者偷懒，他们重复，因为那样似乎更容易
   - 在项目有时间压力的挑战下，如果可以避免无奈性的重复，更能体现个人能力。
- 开发者之间的重复(interdeveloper)：同一个团队（或不同团队）的几个人重复了同样的信息
   - 鼓励开发者相互进行主动的交流
      - 设置论坛讨论常见的问题，可以永久保留所有讨论的痕迹

**原则2**：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/758294/1709543799118-0fd1727b-738e-4cff-9251-c495cefb1ea5.png#averageHue=%23aaaaaa&clientId=ue647fcaa-c1e8-4&from=paste&height=117&id=u4c582de3&originHeight=148&originWidth=724&originalType=binary&ratio=2&rotation=0&showTitle=false&size=20867&status=done&style=none&taskId=ub570f300-1bf7-4a4d-90c2-eac7c0296af&title=&width=573)
如果复用很难，大家就不会去复用。所以要营造一种环境，让复用变得更容易。

## 正交性
![image.png](https://cdn.nlark.com/yuque/0/2024/png/758294/1709543842970-8104fda2-9164-4a35-9b07-b479fde9d664.png#averageHue=%239f9f9f&clientId=ue647fcaa-c1e8-4&from=paste&height=337&id=u8ae0cc59&originHeight=198&originWidth=256&originalType=binary&ratio=2&rotation=0&showTitle=false&size=22913&status=done&style=none&taskId=u435d0e46-64e3-4760-a94b-32f2721bed7&title=&width=436)
正交性：是从几何学中借来的术语，如果两条直线相交成直角，他们就是正交的。
### 书中观点
**正交性指**：用于表示某种不相依赖或是解耦性。如果多个事务中的一个发生变化，不会影响其他事物，这些事物就是正交的。
**原则：**
![image.png](https://cdn.nlark.com/yuque/0/2024/png/758294/1709543821418-775e756d-9cf4-4a38-af00-7d07d4a7c89b.png#averageHue=%23a8a8a8&clientId=ue647fcaa-c1e8-4&from=paste&height=100&id=u6cb78a63&originHeight=148&originWidth=735&originalType=binary&ratio=2&rotation=0&showTitle=false&size=28659&status=done&style=none&taskId=ucc5d28b1-061e-4820-a898-1114c19db04&title=&width=498.5)
**好处：**

- 提高生产率
   - 改动影响局部化，开发时间和测试时间降低
   - 促进复用。如果组件有明确而具体的、良好定义的责任，就可以在新场景进行复用。 和乐高的思想一致，拼乐高，实际上就是在搭积木。
   - 对正交的组件进行组合，做的事情会更多，某个组件做M件事情，另外的组件做N件事情，正交会实现M x N的效果。如果非正交，做的事情就会重叠。
- 降低风险
   - 有问题的代码区域被隔离开来。不会影响到系统的其他部分同时更换成健康的新模块也会更容易
   - 系统更健壮。对特定区域做出小的改动与修改，所导致的任务问题都将局限在改区域中
   - 正交系统很容易得到更好的测试

**实际应用**：

- 项目团队
   - 怎么把团队划分为责任得到了良好定义的小组，并使重叠将至最低？
   - 量化的指标：每个需求改动时需要涉及多少人。人数越多，团队的正交性越差
   - 没有简单的方案，取决于项目、变动的区域、人员
- 系统设计
   - 使用模块化、基于组件、分层的思想指导系统设计
   - 量化的指标：如果显著地改变某个特定功能背后的需求，有多少模块会受影响。数据越多，系统设计的正交性越差
- 编码
   - 代码保持解耦
      - 通过接口抽象的方式，实现代码内聚
   - 避免使用全局数据
   - 避免编写相似的函数
      - 策略模式
### 引用观点
实际上耦合的架构、代码设计会降低效率，好的业务架构，本质想尽一切办法减少沟通，只有沟通少，效率才会高，质量才会好。而好的业务架构需要一些**可衡量的指标**。
陶文的在一篇标题为“代码防腐实用技术”中给出一个解法，怎么衡量一个业务架构拆分是否合理
**业务逻辑的拆分，从编辑时和运行时**

- **编辑时：拆分成文件、文件夹、Git仓库 **
   - **为什么拆分成文件、文件夹、Git仓库？**
      - 这种拆分标准屏蔽了不同编程语言和编程框架的影响，不用争论什么是Class，什么是Module，什么是Package。
   - **目标是**：“代码防腐”
   - **拆分不当的症状是什么？**
      - 沟通多：做新需求很难，因为需要牵涉到很多的团队，要和大量的人去沟通才能把需求落地。
      - 需求做了就删不掉：一旦需求做进去了之后，即便愿意把这个功能下线也非常困难。遗留代码日积月累。
   - **量化的指标（列举部分）**
      - **会议时间**
         - 如果一个需求的改动需要花费大量的沟通成本，需要重新审视业务逻辑拆
      - **接口改动/实现改动 比率**
         - 可以指导仓库拆分的成本
         - 如果实现改动的非常多，指导使用配置化的方式
      - **过度抽象怎么衡量**
         - 强行把一堆不相关的东西拧巴到一起，引入了“必要参数占比”和“咨询量”
         - **必要参数占比**
            - 调用方是否必传的参数
            - 如果必要参数占比过小，把一些小众场景的具体业务以额外的方式加进来了，每个额外参数都增加了调用者的负担，是额外的学习和维护成本
         - **咨询量**
            - 针对的是可复用模块，模块的使用成本很高，文档不清楚，沟通成本很大
- **运行时：拆分成进程**
   - **为什么拆分成进程？**
      - 避免拆分出来的东西见仁见智，我们只能选择不那么用户可见，但是又相对稳定的东西。进程是歧义比较少的东西。
   - **目标是：**“只负责自己写的代码”
      - **负责**
         - 开发者应该对自己的线上服务负责，也就是所谓的 devops。而不是写好了代码之后，甩给运维去管。不仅仅要自己发布变更，也要接告警，定位问题。
      - **自己写的代码**
         - 搞别人的代码是很烦躁的，无论是发布变更，还是告警定位，我们都希望能快速验证自己写的代码是不是有问题，然后把锅甩出去。
   - **进程拆分不好的症状有哪些？**
      - 故障定位慢：线上出了bug，要花很长时间才能定位出问题的代码以及对应的开发者。
      - 本地测试难：稍微有点价值的测试都不是本地可以用 JUnit 写出来的。
      - 听不见炮火：管你前线洪水滔天，我这后台模块是管不着的
   - **量化进程拆分好的指标有哪些？**
      - **工单流转时长**
         - 企业的外部用户创建的工单，如果最终发现需要开发来处置，到转到对应的开发手里。这个从工单创建时间，到开发开始处置的时间差，就是工单流转延迟。 度量这个指标主要是为了避免后台模块缺乏对企业最终用户的体验缺乏同情心，减少中间的层次。 这里工单指的是偶发的个案。对于大面积故障造成的工单，一天之内的工单合并为记录为一条。也就是数据采样的时候，一天只抽取一条工单纳入指标。
      - **故障定位时长**
         - 孤立的一个进程很难完成所有工作。业务逻辑不可避免地要拆分成多个进程。如何找到出问题的进程。 一个进程也很难仅由一个 Git 仓库构建而来。业务逻辑不可避免地要拆分成多个 Git 仓库。如何找到进程的问题是哪个 Git 仓库造成的。 故障定位延迟是指故障从开始定位，到找到根本原因所花的时间。进程边界，Git 仓库的边界，越不依赖人的经验，越不依赖人的现场沟通，就越可能降低故障定位延迟。
      - **代码集成时长**
         - 从修改一行代码，到把这行代码修改和其他进程集成到一起，用真实流量验证，这个端到端的延迟是多少。 开发自己的笔记本能把所有的进程都能启动起来是一种办法。 开发能用单元测试模拟试也是一种办法。 每个小时上一次线也是一种办法。 只要能对刚才改的那行代码，集成起来不出问题有信心就可以。 
# 总结
1、负责，体现在如何处理问题，应该给出多个选择方案，而不是找借口
2、不要留破窗户，代码质量问题往往就是从一次“破窗户”开始的
3、作为一名程序员，需要坚持终身学习，修炼内功，保持技术敏感度
4、交流，在适当的时机说适当的话
5、DRY原则，减少重复，关注复用
6、抽象比细节活得更加长久
7、自动化提效
# 附录
1、工程师应该怎么学习 [https://xargin.com/how-to-learn/](https://xargin.com/how-to-learn/)
2、那些年，我从微信支付学到的东西 [https://mp.weixin.qq.com/s/qvTWcsjAPTJTEu30zapsQg](https://mp.weixin.qq.com/s/qvTWcsjAPTJTEu30zapsQg)
3、代码防腐实用技术 [https://autonomy.design/Modules.html](https://autonomy.design/Modules.html)
